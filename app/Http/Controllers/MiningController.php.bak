<?php

namespace App\Http\Controllers;

use App\Models\MiningProduct;
use Illuminate\Http\Request;
use Illuminate\View\View;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Auth;
use Illuminate\Http\RedirectResponse;

class MiningController extends Controller
{
    /**
     * Display the mining homepage.
     *
     * @return \Illuminate\View\View
     */
    public function index(): View
    {
        $featuredProducts = MiningProduct::where('featured', true)
            ->take(4)
            ->get();
            
        $asicMiners = MiningProduct::where('algorithm', 'SHA-256')
            ->take(3)
            ->get();
            
        $gpuMiners = MiningProduct::where('algorithm', 'like', '%Ethash%')
            ->take(3)
            ->get();
            
        $accessories = MiningProduct::whereIn('name', ['Mining Rig Frame', 'Bitmain Power Supply APW9+', 'Immersion Cooling Kit'])
            ->take(3)
            ->get();
            
        return view('mining.index', compact(
            'featuredProducts',
            'asicMiners',
            'gpuMiners',
            'accessories'
        ));
    }
    
    /**
     * Display all mining products.
     *
     * @return \Illuminate\View\View
     */
    public function products(): View
    {
        $miningProducts = MiningProduct::paginate(12);
        
        return view('mining.products', compact('miningProducts'));
    }
    
    /**
     * Display a single mining product.
     *
     * @param  int  $id
     * @return \Illuminate\View\View
     */
    public function show($id): View
    {
        $product = MiningProduct::findOrFail($id);
        $relatedProducts = MiningProduct::where('id', '!=', $id)
            ->where(function($query) use ($product) {
                $query->where('algorithm', $product->algorithm)
                    ->orWhere('power_consumption', '<=', $product->power_consumption + 100)
                    ->orWhere('power_consumption', '>=', $product->power_consumption - 100);
            })
            ->take(4)
            ->get();
            
        return view('mining.show', compact('product', 'relatedProducts'));
    }
    
    /**
     * Display the mining calculator page.
     *
     * @return \Illuminate\View\View|\Illuminate\Http\RedirectResponse
     */
    public function calculator()
    {
        // Require authentication for the calculator
        if (!Auth::check()) {
            return redirect()->route('login')->with('message', 'Please login to access the mining calculator.');
        }
        
        $miningProducts = MiningProduct::whereNotIn('hashrate', ['N/A'])->get();
        
        // Get cryptocurrency prices for display on the calculator page
        $cryptoPrices = Cache::remember('crypto_prices', 300, function () {
            return $this->getCryptoPrices();
        });
        
        return view('mining.calculator', compact('miningProducts', 'cryptoPrices'));
    }
    
    /**
     * Calculate mining profitability based on user input
     * 
     * @param \Illuminate\Http\Request $request
     * @return \Illuminate\Http\JsonResponse
     */
    public function calculateProfitability(Request $request)
    {
        // Validate the request data
        $validated = $request->validate([
            'hashrate' => 'required|numeric|min:0',
            'hashrate_unit' => 'required|string|in:TH,GH,MH,KH',
            'power_consumption' => 'required|numeric|min:0',
            'electricity_cost' => 'required|numeric|min:0',
            'algorithm' => 'required|string|in:SHA-256,Ethash,Scrypt,X11,RandomX',
            'pool_fee' => 'required|numeric|min:0|max:100',
            'price_refresh_only' => 'nullable|boolean'
        ]);
        
        // If this is just a price refresh request, return the current prices
        if (isset($validated['price_refresh_only']) && $validated['price_refresh_only']) {
            return response()->json([
                'prices' => $this->getCryptoPrices()
            ]);
        }
        
        // Get crypto prices from cache or API
        $cryptoPrices = Cache::remember('crypto_prices', 300, function () {
            return $this->getCryptoPrices();
        });
        
        // Normalize hashrate to TH/s for calculations
        $hashrate = $this->normalizeHashrate($validated['hashrate'], $validated['hashrate_unit']);
        
        // Determine which cryptocurrency based on algorithm
        $cryptoData = $this->getCryptoDataByAlgorithm($validated['algorithm']);
        $cryptoSymbol = $cryptoData['symbol'];
        $cryptoPrice = $cryptoPrices[$cryptoSymbol] ?? $this->getFallbackPrices()[$cryptoSymbol];
        
        // Network difficulty and block reward values (simplified for calculation)
        $networkDifficulty = $cryptoData['difficulty'];
        $blockReward = $cryptoData['block_reward'];
        $blocksPerDay = $cryptoData['blocks_per_day'];
        
        // Calculate mining rewards in cryptocurrency
        $poolFeePercentage = $validated['pool_fee'] / 100;
        $dailyReward = $this->calculateDailyReward($hashrate, $networkDifficulty, $blockReward, $blocksPerDay, $poolFeePercentage);
        
        // Calculate power costs
        $dailyPowerCost = $this->calculatePowerCost($validated['power_consumption'], $validated['electricity_cost']);
        
        // Calculate rewards in USD
        $dailyRewardUsd = $dailyReward * $cryptoPrice;
        
        // Calculate profit
        $dailyProfit = $dailyRewardUsd - $dailyPowerCost;
        $monthlyProfit = $dailyProfit * 30;
        $yearlyProfit = $dailyProfit * 365;
        
        // Calculate monthly and yearly costs
        $monthlyPowerCost = $dailyPowerCost * 30;
        $yearlyPowerCost = $dailyPowerCost * 365;
        
        // Calculate monthly and yearly crypto rewards
        $monthlyReward = $dailyReward * 30;
        $yearlyReward = $dailyReward * 365;
        
        return response()->json([
            'daily_reward' => number_format($dailyReward, 8),
            'monthly_reward' => number_format($monthlyReward, 8),
            'yearly_reward' => number_format($yearlyReward, 8),
            'daily_reward_usd' => number_format($dailyRewardUsd, 2),
            'daily_power_cost' => number_format($dailyPowerCost, 2),
            'daily_profit' => number_format($dailyProfit, 2),
            'monthly_power_cost' => number_format($monthlyPowerCost, 2),
            'monthly_profit' => number_format($monthlyProfit, 2),
            'yearly_power_cost' => number_format($yearlyPowerCost, 2),
            'yearly_profit' => number_format($yearlyProfit, 2),
            'crypto_symbol' => $cryptoSymbol,
            'crypto_price' => $cryptoPrice,
            'using_live_prices' => !isset($cryptoPrices['is_fallback']),
            'price_updated_at' => isset($cryptoPrices['timestamp']) ? date('Y-m-d H:i:s', $cryptoPrices['timestamp']) : date('Y-m-d H:i:s')
        ]);
    }
    
    /**
     * Normalize hashrate to TH/s for calculations
     * 
     * @param float $hashrate
     * @param string $unit
     * @return float
     */
    private function normalizeHashrate($hashrate, $unit)
    {
        switch ($unit) {
            case 'KH':
                return $hashrate / 1000000000; // KH/s to TH/s
            case 'MH':
                return $hashrate / 1000000; // MH/s to TH/s
            case 'GH':
                return $hashrate / 1000; // GH/s to TH/s
            case 'TH':
            default:
                return $hashrate; // Already in TH/s
        }
    }
    
    /**
     * Get cryptocurrency data based on mining algorithm
     * 
     * @param string $algorithm
     * @return array
     */
    private function getCryptoDataByAlgorithm($algorithm)
    {
        // Cryptocurrency network data (simplified for calculation purposes)
        $cryptoData = [
            'SHA-256' => [
                'symbol' => 'BTC',
                'name' => 'Bitcoin',
                'difficulty' => 125 * 1000000, // Simplified network difficulty factor
                'block_reward' => 6.25, // Current BTC block reward
                'blocks_per_day' => 144, // ~10 minutes per block
            ],
            'Ethash' => [
                'symbol' => 'ETH', 
                'name' => 'Ethereum',
                'difficulty' => 15 * 1000000, // Simplified network difficulty factor
                'block_reward' => 2.0, // ETC block reward (as ETH is now PoS)
                'blocks_per_day' => 6000, // ~15 seconds per block (for ETC)
            ],
            'Scrypt' => [
                'symbol' => 'LTC',
                'name' => 'Litecoin',
                'difficulty' => 20 * 1000000,
                'block_reward' => 12.5,
                'blocks_per_day' => 576, // ~2.5 minutes per block
            ],
            'X11' => [
                'symbol' => 'DASH',
                'name' => 'Dash',
                'difficulty' => 5 * 1000000,
                'block_reward' => 3.11,
                'blocks_per_day' => 576, // ~2.5 minutes per block
            ],
            'RandomX' => [
                'symbol' => 'XMR',
                'name' => 'Monero',
                'difficulty' => 3 * 1000000,
                'block_reward' => 0.8,
                'blocks_per_day' => 720, // ~2 minutes per block
            ],
        ];
        
        return $cryptoData[$algorithm] ?? $cryptoData['SHA-256'];
    }
    
    /**
     * Calculate daily mining reward in cryptocurrency
     * 
     * @param float $hashrate Hashrate in TH/s
     * @param float $difficulty Network difficulty
     * @param float $blockReward Block reward
     * @param int $blocksPerDay Blocks mined per day
     * @param float $poolFee Pool fee as decimal (0.01 = 1%)
     * @return float
     */
    private function calculateDailyReward($hashrate, $difficulty, $blockReward, $blocksPerDay, $poolFee)
    {
        // Calculate share of daily blocks based on your hashrate vs network difficulty
        $yourShareOfBlocks = ($hashrate / $difficulty) * $blocksPerDay;
        
        // Calculate rewards and apply pool fee
        $rewards = $yourShareOfBlocks * $blockReward;
        $rewardsAfterFee = $rewards * (1 - $poolFee);
        
        return $rewardsAfterFee;
    }
    
    /**
     * Calculate daily power cost
     * 
     * @param float $powerConsumption Power consumption in watts
     * @param float $electricityCost Electricity cost per kWh
     * @return float
     */
    private function calculatePowerCost($powerConsumption, $electricityCost)
    {
        // Convert watts to kilowatts and calculate daily consumption
        $dailyPowerUsage = ($powerConsumption / 1000) * 24; // kWh per day
        
        // Calculate daily power cost
        $dailyCost = $dailyPowerUsage * $electricityCost;
        
        return $dailyCost;
    }
    
    /**
     * Get live cryptocurrency prices from CoinMarketCap API
     * 
     * @return array
     */
    private function getCryptoPrices()
    {
        $apiKey = env('COINMARKETCAP_API_KEY');
        $symbols = 'BTC,ETH,LTC,DASH,XMR'; // Bitcoin, Ethereum, Litecoin, Dash, Monero
        
        try {
            $url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest?symbol={$symbols}";
            $headers = [
                'X-CMC_PRO_API_KEY: ' . $apiKey,
                'Accept: application/json'
            ];
            
            $curl = curl_init();
            curl_setopt_array($curl, [
                CURLOPT_URL => $url,
                CURLOPT_HTTPHEADER => $headers,
                CURLOPT_RETURNTRANSFER => true,
                CURLOPT_TIMEOUT => 30,
                CURLOPT_SSL_VERIFYHOST => false,
                CURLOPT_SSL_VERIFYPEER => false,
            ]);
            
            $response = curl_exec($curl);
            $err = curl_error($curl);
            
            curl_close($curl);
            
            if ($err) {
                // Log the error but use fallback prices
                Log::error("CoinMarketCap API Error: {$err}");
                return $this->getFallbackPrices();
            }
            
            $data = json_decode($response, true);
            if (!isset($data['data'])) {
                Log::error("CoinMarketCap API returned invalid data: " . json_encode($data));
                return $this->getFallbackPrices();
            }
            
            // Extract prices
            $prices = [];
            foreach ($data['data'] as $symbol => $coinData) {
                $prices[$symbol] = $coinData['quote']['USD']['price'];
            }
            
            // Add timestamp for caching purposes
            $prices['timestamp'] = time();
            
            // Cache the prices for 5 minutes to avoid excessive API calls
            Cache::put('crypto_prices', $prices, 300);
            
            return $prices;
        } catch (\Exception $e) {
            Log::error("CoinMarketCap API Exception: " . $e->getMessage());
            return $this->getFallbackPrices();
        }
    }
    
    /**
     * Provide fallback prices in case the API call fails
     * 
     * @return array
     */
    private function getFallbackPrices()
    {
        return [
            'BTC' => 10000,
            'ETH' => 1000,
            'LTC' => 100,
            'DASH' => 10,
            'XMR' => 100,
            'timestamp' => time(),
            'is_fallback' => true
        ];
    }
} 